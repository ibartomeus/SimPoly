#' Create true abundances per site and year
#'
#' This function calculate true abundance in each sampling round.
#'
#' @param n_round Numeric. Number of sampling rounds. Default to 8.
#' @param startmonth Numeric. Number of month starting to sample. Default to 2.
#' @param endmonth Numeric. Number of month stopping to sample. Default to 10.
#' @param site_years A data.frame, generated by define_sites_years()
#' @param sp_responses A data.frame, generated by sp_responses()
#' @param white_noiseCV Numeric, the expected CV across years. Default to 0.5 (use values 0-1)
#'
#' @details Rounds are distributed homogeneously across the sampling period. Natural yearly fluctuations
#' (i.e. white noise) are assumed to follow a normal distribution with a mean corresponding to the species
#'  peak abundance and sd calculated from the provided coeficient of variation. Hence, we add white noise
#'  proportional to species abundances. Based on Tereno and BeeFun data, expected CV is around 0.5. Negative values are truncated to 0. Population trends (i.e. red noise)
#'  are incorporated to each species and year by multiplying the species mean abundance by the provided slope
#'  of the linear trend and the number of years modeled. Hence, the more years, the larger the change expected.
#'  Finally, we use coenocliner package to calculate for each species a gausian abundance distribution along each year
#'  with the calculated species peak abundance for each year and site, and its phenological peak and range. From this
#'  distribution we sample at each round using a negative binomial count model. This gives us for each species, site, year
#'  and round a value for the expecued true abundance.
#'
#' @return A data.frame.
#' @export
#'
#' @examples
#' site_years <- define_sites_years(nsp = 100, n_years = 3, n_sites = 10)
#' pars <- sp_responses(site_years = site_years)
#' true_abundance(n_round = 8,
#'                site_years = site_years,
#'                sp_responses = pars)
true_abundance <- function(n_round = 8, startmonth = 2, endmonth = 10,
                           site_years = NA, sp_responses = NA, white_noiseCV = 0.5){
  #require(reshape2)
  #require(coenocliner)
  #Define sampling events per year:
  data <- site_years
  pars <- sp_responses
  #Rounds are constrained from February to October by default.
  rounds <- ceiling(seq(startmonth*30, endmonth*30, length = n_round)) # gradient locations (sampling points)
  #Calculate abundande per site and year
  n_years <- max(data$year)
  site_names <- unique(data$siteID)
  #mus <- list() #store in lists if needed (do we need to keep track of this?)
  #For now we store final counts only
  #simnbs <- data.frame(year = NA, siteID = NA, round = NA, jday = NA, species = NA, abundance = NA)
  simnbs <- future.apply::future_lapply(1:n_years, function(j){
    #for(j in 1:n_years){
    #select year j
    year_temp <- subset(data, year == j)
    #We add white noise to h as a function of year (yearly fluctuations)
    #white_noise <- rnorm(length(pars$h), 0, 0.05) #this is very little white noise. It can be added to red noise below.
    sd = pars$h*white_noiseCV #mean * CV
    pars$h2 <- pars$h
    for(k in 1:length(pars$h)){
      pars$h2[k] <- rnorm(1, pars$h[k], sd[k]) #this adds white noise proportional to species abundances.
    }
    pars$h2 <- ifelse(pars$h2 < 0, 0, pars$h2)
    #plot(pars$h2, pars$h)
    #And a directional noise (red noise) based on species responses.
    pars$h_y <- pars$h2 * ((pars$slope)^j) #can never get negative, just terribly small.

    #for(i in 1:length(site_names)){
    simnbs1 <- future.apply::future_lapply(1:length(site_names), function(i){
      #select site i
      site_temp <- subset(data, siteID == site_names[i])
      #select species present in site i
      pars_temp <- pars[which(pars$species %in% site_temp$species),]
      pars_i <- cbind(opt = pars_temp$opt, tol = pars_temp$tol, h = pars_temp$h_y)
      #create ideal community
      #mus[[i]]  <- coenocline(locs, responseModel = "gaussian", params = pars_i,
      #  expectation = TRUE)
      #plot(mus[[i]], lty = "solid", type = "l", ylim = c(0,100), xlab = "jday", ylab = "Abundance", las= 1)
      #create observed community
      simnb <- coenocliner::coenocline(rounds, responseModel = "gaussian", params = pars_i,
                                       countModel = "negbin", countParams = list(alpha = 0.5))
      #transform the sim to long format
      sim <- as.data.frame(simnb) #we lose species names
      colnames(sim) <- pars_temp$species
      sim$rounds <- 1:length(rounds)
      sim$jday <- rounds
      sim_melted <- reshape2::melt(data = sim, id.vars = c("rounds", "jday"), preserve.na = T)
      sim_melted$siteID <- site_names[i]
      sim_melted$year <- j
      sim_melted <- sim_melted[,c("rounds", "jday", "variable", "value", "siteID", "year")]
      colnames(sim_melted) <- c("round", "jday", "species", "abundance", "siteID", "year")
      return(sim_melted[,c("year", "siteID", "round", "jday", "species", "abundance")])
      #simnbs <- rbind(simnbs, sim_melted[,c("year", "siteID", "round", "jday", "species", "abundance")])
    }, future.seed=TRUE)
    #simnbs <- simnbs[-1,] # not sure what this is for
    #head(simnbs)
    return(do.call(rbind,  simnbs1))
  }, future.seed=TRUE)
  return(do.call(rbind,  simnbs))
}
